<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recorder Bridge Test (fetch & play)</title>
  <style>
    body { font-family: system-ui, -apple-system; margin: 24px; }
    button { padding: 10px 14px; margin: 4px; border-radius: 10px; }
    #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    #player { width: 100%; display: none; margin-top: 12px; }
    #download { display: none; margin-left: 8px; }
    .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <h1>Recorder Bridge Test (fetch & play)</h1>

  <div class="row">
    <span>Status: <strong id="status">bereit</strong></span>
    <button onclick="startRecording()">Start native recording</button>
    <button onclick="clearPlayer()">Clear</button>
    <a id="download" download>Download file</a>
  </div>

  <audio id="player" controls></audio>
  <pre id="log"></pre>

  <script>
    const $ = sel => document.querySelector(sel);
    const log = (...args) => { $('#log').textContent += args.join(' ') + '\n'; };

    // Small helper: fetch with XHR fallback (WKWebView can be picky on some setups)
    async function fetchBlobCustom(url) {
      // 1) Try fetch
      try {
        const resp = await fetch(url, { cache: 'no-store' });
        log('[fetch] ok:', resp.ok, 'status:', resp.status, 'type:', resp.type);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.blob();
      } catch (e) {
        log('[fetch] failed ->', e?.message || e);
        // 2) Fallback: XHR
        return await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'blob';
          xhr.onload = () => resolve(xhr.response);
          xhr.onerror = () => reject(new Error('XHR failed'));
          xhr.send();
        });
      }
    }

    // Optional: avoid race right after "finished"
    const nextTick = () => Promise.resolve();

    // Build a short preview of first bytes (for debugging)
    async function describeBlob(blob) {
      if (!blob) return 'n/a';
      const head = await blob.slice(0, 16).arrayBuffer();
      const bytes = new Uint8Array(head);
      const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
      return `size=${blob.size}, type=${blob.type || '(unknown)'}, head=[${hex}]`;
    }

    // Native -> Web events
    window.onRecordingEvent = async (evt) => {
      log('[event]', JSON.stringify(evt));
      $('#status').textContent = evt.type;

      if (evt.type === 'finished' && evt.url) {
        try {
          log('finished -> fetching:', evt.url);
          await nextTick();

          // Fetch into a Blob
          const blob = await fetchBlobCustom(evt.url);
          log('blob fetched:', await describeBlob(blob));

          // Feed <audio> with an object URL
          const url = URL.createObjectURL(blob);
          const player = $('#player');
          player.src = url;
          player.style.display = 'block';

          // Optional: auto-play (can be blocked by autoplay policies)
          try { await player.play(); } catch (e) { log('player.play blocked:', e?.message || e); }

          // Expose a download link
          const dl = $('#download');
          dl.href = url;
          dl.download = `${evt.id || 'recording'}.m4a`;
          dl.textContent = 'Download';
          dl.style.display = 'inline-block';

          log('object URL set on player & download link ready.');

        } catch (err) {
          log('ERROR fetching blob:', err?.message || err);
        }
      }
    };

    function startRecording() {
      if (window.webkit?.messageHandlers?.recorder) {
        window.webkit.messageHandlers.recorder.postMessage({ action: "startNativeRecording" });
        log('startNativeRecording sent (iOS)');
      } else if (window.AndroidBridge) {
        window.AndroidBridge.postMessage(JSON.stringify({ action: "startNativeRecording" }));
        log('startNativeRecording sent (Android)');
      } else {
        log('No native bridge available');
      }
    }

    function clearPlayer() {
      const player = $('#player');
      const dl = $('#download');
      if (player.src) {
        try { URL.revokeObjectURL(player.src); } catch (_) {}
      }
      player.removeAttribute('src');
      player.style.display = 'none';
      dl.removeAttribute('href');
      dl.style.display = 'none';
      $('#log').textContent += 'cleared player/download\n';
    }

    // Log <audio> errors for visibility
    $('#player').addEventListener('error', () => {
      const e = $('#player').error;
      log('AUDIO ERROR', e?.code, e ? JSON.stringify(e, Object.getOwnPropertyNames(e)) : '');
    });
  </script>
</body>
</html>
